
<#
    .Synopsis
    Creates a set of parameters to be used with Invoke-WebRequest to call S1 API

    .Description
    Creates a set of parameters to be used with Invoke-WebRequest to call S1 API. Body will be empty JSON, so if your request needs a body, you must create JSON body content and add it to the
    returned hashtable before using Invoke-WebRequest

    .Example
    $restParams = Get-RestParams -Endpoint 'update/agent/packages' -Subdomain 'some-subdomain' -Token 'sometoken'
    PS > Invoke-RestMethod @restParams
    Makes a GET request to https://some-subdomain.sentinelone.net/web/api/v2.1/update/agent/packages and includes specified token in the request

    .Example
    $restParams = Get-RestParams -Endpoint 'users/some-endpoint' -Subdomain 'some-subdomain' -Token 'sometoken' -Method 'POST'
    PS > $restParams.Body = ConvertTo-Json @{ 'data' = @{ 'some-key' = 'some-data' } }
    PS > Invoke-RestMethod @restParams
    Makes a POST request to https://some-subdomain.sentinelone.net/web/api/v2.1/users/some-endpoint and includes specified token in the request and specified JSON data as body
#>
Function Get-RestParams {
    param(
        [Parameter(Mandatory = $True)]
        [string]$Endpoint,
        [Parameter(Mandatory = $True)]
        [string]$Token,
        [Parameter(Mandatory = $True)]
        [string]$Subdomain,
        [Parameter(Mandatory = $False)]
        [hashtable]$QueryParams = @{},
        [Parameter(Mandatory = $False)]
        [string]$Method = 'GET'
    )

    $Uri = "https://$Subdomain.sentinelone.net/web/api/v2.1/$Endpoint"

    If ($QueryParams.Keys.Count) {
        $qpStrings = @()
        $QueryParams.Keys | ForEach-Object { $qpStrings += "$_=$($QueryParams[$_])" + '&' }
        $Uri += '?' + $qpStrings -replace ' ', ''
    }

    Return @{
        'Uri'           = $Uri
        'Method'        = $Method
        'ErrorVariable' = 'RESTError'
        'ContentType'   = 'application/json'
        'Headers'       = @{ 'Authorization' = "APIToken $Token" }
        'Body'          = ConvertTo-Json @{}
    }
}

<#
    .Synopsis
    Allows you to check the status of the API token you're using.

    .Description
    Given a token string and a subdomain, will check that token with S1 API and return info on that token: created date, expiration date, and current validity of token

    .Outputs
    System.Object that contains 'isValid', 'expiresAt' and 'createdAt' values

    .Example
    Get-S1TokenDetails -Token 'sometoken'
    Use default pax8 subdomain

    .Example
    Get-S1TokenDetails -Token 'sometoken' -Subdomain 'some-subdomain'
    Would result in checking the token against S1 at https://some-subdomain.sentinelone.net
#>
Function Get-S1TokenDetails {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $True)]
        # The S1 API requires authentication. Provide a token generated by a user in the S1 console.
        [string]$Token,
        [Parameter(Mandatory = $False)]
        # S1 subdomain. Defaults to pax8. If you provided 'some-subdomain' the resulting URL would look like https://some-subdomain.sentinelone.net
        [string]$Subdomain = 'usea1-pax8'
    )

    $restParams = Get-RestParams -Endpoint 'users/api-token-details' -Subdomain $Subdomain -Method 'POST' -Token $Token
    $restParams.Body = ConvertTo-Json @{ 'data' = @{ 'apiToken' = $Token } }

    Try {
        $result = Invoke-RestMethod @restParams -ErrorAction Stop

        $expiresAt = ([datetime]$result.data.expiresAt).tostring('yyyy-MM-dd HH:mm:ss')
        $createdAt = ([datetime]$result.data.createdAt).tostring('yyyy-MM-dd HH:mm:ss')
        $isValid = ([datetime]$result.data.expiresAt) -gt (Get-Date)
    } Catch {
        $isValid = $False
        $expiresAt = $null
        $createdAt = $null
    }

    Return New-Object PSObject -Property @{
        'isValid'   = $isValid
        'expiresAt' = $expiresAt
        'createdAt' = $createdAt
    }
}

<#
    .Synopsis
    Returns the latest S1 package ID for a given OS and arch.

    .Description
    Returns the latest S1 package ID for a given OS and arch. This is necessary when triggering an S1 upgrade. Returns either Error, or packageId as a string. Can optionally return object.

    .Outputs
    System.String OR System.Object

    .Example
    Get-S1LatestPackageId -Token 'sometoken'
    Use default values

    .Example
    Get-S1LatestPackageId -Token 'sometoken' -Platform 'linux' -FileExtension '.deb'
    Specifies linux OS and specifies .deb file extension
#>

Function Get-S1LatestPackageId {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $True)]
        # The S1 API requires authentication. Provide a token generated by a user in the S1 console.
        [string]$Token,
        [Parameter(Mandatory = $False)]
        # Intended Architecture. String or INT. Default 64. Accepts 64 or 32.
        [string]$Arch = 64,
        [Parameter(Mandatory = $False)]
        # Intended platform. Default windows. Possible values located in S1 API documentation.
        [string]$Platform = 'windows',
        [Parameter(Mandatory = $false)]
        # Preferred file extension. No need to specify if no preference.
        [string]$FileExtension,
        [Parameter(Mandatory = $False)]
        # S1 tenant subdomain. Defaults to pax8. If you provided 'some-tenant' the resulting URL would look like https://some-tenant.sentinelone.net
        [string]$Subdomain = 'usea1-pax8',
        [Parameter(Mandatory = $False)]
        # The package required status. Defaults to 'ga' or 'generally available' but you could specify beta or etc.. See API documentation / package documentation for details.
        [string]$Status = 'ga',
        [Parameter(Mandatory = $False)]
        # If specified, will return the entire package object returned by the S1 API
        [switch]$ReturnObject
    )

    # Check API token validity first.
    $tokenResult = Get-S1TokenDetails -Token $Token
    If (!$tokenResult.isValid) {
        Throw 'The token is not valid!! Please check this token or create a new token!'
    }

    $queryParams = @{
        osArches = "$arch%20bit"
        sortBy = 'version'
        sortOrder = 'desc'
        status = $Status
        platformTypes = $Platform
    }

    If ($FileExtension) {
        $queryParams.Add('fileExtension', $FileExtension)
    }

    $restParams = Get-RestParams -Endpoint 'update/agent/packages' -Subdomain $Subdomain -Token $Token -QueryParams $queryParams

    Try {
        $result = Invoke-RestMethod @restParams -ErrorAction Stop
    } Catch {
        Throw $Error[0]
    }

    If (!$result.data.length) {
        Throw 'No results returned from Query!'
    }

    If ($ReturnObject) {
        Return $result.data[0]
    } Else {
        Return $result.data[0].id
    }
}

<#
    .Synopsis
    Same as Get-S1LatestPackageId except meant to be run on target computer

    .Description
    Same as Get-S1LatestPackageId except meant to be run on target computer. Will detect OS and architecture and get latest applicable S1 package ID.
    Currently only supports windows.

    .Outputs
    System.String OR System.Object

    .Example
    Get-S1LatestPackageIdForThisComputer -Token 'sometoken'
    Gets latest applicable S1 package ID for machine that this runs on
#>
Function Get-S1LatestPackageIdForThisComputer {
    param(
        [Parameter(Mandatory = $True)]
        # The S1 API requires authentication. Provide a token generated by a user in the S1 console.
        [string]$Token,
        [Parameter(Mandatory = $false)]
        # Preferred file extension. No need to specify if no preference.
        [string]$FileExtension,
        [Parameter(Mandatory = $False)]
        # S1 subdomain. Defaults to pax8. If you provided 'some-subdomain' the resulting URL would look like https://some-subdomain.sentinelone.net
        [string]$Subdomain = 'usea1-pax8',
        [Parameter(Mandatory = $False)]
        # The package required status. Defaults to 'ga' or 'generally available' but you could specify beta or etc.. See API documentation / package documentation for details.
        [string]$Status = 'ga',
        [Parameter(Mandatory = $False)]
        # If specified, will return the entire package object returned by the S1 API
        [switch]$ReturnObject
    )

    $osDeets = Get-CimInstance win32_operatingsystem
    $osName = $osDeets.Caption
    $osArch = $osDeets.OSArchitecture

    If ($osArch -eq '64-bit') {
        $arch = 64
    } Else {
        $arch = 32
    }

    If ($osName -like '*windows*') {
        $platform = 'windows'
    } Else {
        Throw "This function does not currently support non-windows operating systems. This script must be updated in order to support this OS. The OS is $osName"
    }

    Return Get-S1LatestPackageId -Arch $arch -ReturnObject:$ReturnObject -FileExtension $FileExtension -Subdomain $Subdomain -Status $Status -Token $Token -Platform $platform
}

<#
    .Synopsis
    Returns the entire computer object from S1, provided a computer name

    .Description
    Given computer name, will pull computer object from S1 and return it. This will include currently installed version of S1, threats detected, UUID, etc..
#>
Function Get-S1Computer {
    Param(
        [Parameter(Mandatory = $True)]
        # Computer name of machine that you need data from S1 API about
        [string]$ComputerName,
        [Parameter(Mandatory = $True)]
        # The S1 API requires authentication. Provide a token generated by a user in the S1 console.
        [string]$Token,
        [Parameter(Mandatory = $False)]
        # S1 subdomain. Defaults to pax8. If you provided 'some-subdomain' the resulting URL would look like https://some-subdomain.sentinelone.net
        [string]$Subdomain = 'usea1-pax8',
        [Parameter(Mandatory = $False)]
        # If SkipTokenValidation is true, the token check in this function won't occur.
        [switch]$SkipTokenValidation
    )

    # Can skip token validation if token is already known to be valid
    If (!$SkipTokenValidation) {
        # Check API token validity first.
        $tokenResult = Get-S1TokenDetails -Token $Token
        If (!$tokenResult.isValid) {
            Throw 'The token is not valid!! Please check this token or create a new token!'
        }
    }

    $restParams = Get-RestParams -Endpoint 'agents' -Subdomain $Subdomain -Token $Token -QueryParams @{
        computerName = $ComputerName
    }

    Try {
        $result = Invoke-RestMethod @restParams -ErrorAction Stop
    } Catch {
        Throw $Error[0]
    }

    Return $result.data
}

<#
    .Synopsis
    Returns S1 UUID for a machine, given it's computer name
#>
Function Get-S1UUID {
    Param(
        [Parameter(Mandatory = $True)]
        # Computer name of machine that you need UUID of
        [string]$ComputerName,
        [Parameter(Mandatory = $True)]
        # The S1 API requires authentication. Provide a token generated by a user in the S1 console.
        [string]$Token,
        [Parameter(Mandatory = $False)]
        # S1 subdomain. Defaults to pax8. If you provided 'some-subdomain' the resulting URL would look like https://some-subdomain.sentinelone.net
        [string]$Subdomain = 'usea1-pax8',
        [Parameter(Mandatory = $False)]
        # If SkipTokenValidation is true, the token check in this function won't occur.
        [switch]$SkipTokenValidation
    )

    Return (Get-S1Computer -ComputerName $ComputerName -Token $Token -Subdomain $Subdomain -SkipTokenValidation:$SkipTokenValidation).uuid
}

<#
    .Synopsis
    Will invoke an S1 upgrade. Must specify both computer name of target machine and S1 package ID.
#>
Function Invoke-S1Upgrade {
    Param(
        [Parameter(Mandatory = $True)]
        # Computer name of target machine that you would like to upgrade
        [string]$ComputerName,
        [Parameter(Mandatory = $True)]
        # The package ID of the S1 upgrade that you would like to install on the target machine.
        [string]$PackageId,
        [Parameter(Mandatory = $True)]
        # The S1 API requires authentication. Provide a token generated by a user in the S1 console.
        [string]$Token,
        [Parameter(Mandatory = $False)]
        # S1 subdomain. Defaults to pax8. If you provided 'some-subdomain' the resulting URL would look like https://some-subdomain.sentinelone.net
        [string]$Subdomain = 'usea1-pax8'
    )

    # Check API token validity first.
    $tokenResult = Get-S1TokenDetails -Token $Token
    If (!$tokenResult.isValid) {
        Throw 'The token is not valid!! Please check this token or create a new token!'
    }

    $uuid = Get-S1UUID -ComputerName $ComputerName -Token $Token -Subdomain $Subdomain -SkipTokenValidation

    $restParams = Get-RestParams -Endpoint 'agents/actions/update-software' -Subdomain $Subdomain -Token $Token -Method 'POST'

    $restParams.Body = ConvertTo-Json @{
        filter = @{
            uuid__contains = @($uuid)
        }
        data = @{
            packageId = $PackageId
        }
    }

    Try {
        $result = Invoke-RestMethod @restParams -ErrorAction Stop
    } Catch {
        Throw $Error[0]
    }

    Return $result
}